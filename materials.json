{
  "q1": "CF  –  Carry  Flag  (флаг  переноса).  В  нем  фиксируется  перенос  из старшего  разряда  при  сложении  и  заем  в  старший  разряд  при  вычитании. При умножении значение флага CF определяет возможность (CF=0) или невозможность (CF=1) представления результата (произведения) в том же формате, что и сомножители. С помощью флага переноса фиксируется переполнение при сложении беззнаковых чисел. \n\nPF  –  Parity  Flag  –  флаг  паритета  ( четности).  Он  устанавливается при наличии четного числа единиц в младшем байте результата, в противном случае – сбрасывается. Этот флаг используется как аппаратная поддержка контроля по четности (нечетности). \n\nAF  –  Аuxiliary  Carry  Flag  (флаг  вспомогательного  переноса).  В этом  флаге  фиксируется  межтетрадный  перенос  при  сложении  и  межтетрадный заем при вычитании. Значение этого флага используется командами десятичной и ASCII-коррекции сложения и вычитания.  \n\nZF  –  Zero  Flag  (флаг  нуля).  Он  устанавливается  при  нулевом  результате операции, в противном случае - сбрасывается. \n\nSF  –  Sign  Flag  (флаг  знака).  В  него  копируется  старший  ( крайний левый) бит результата, интерпретируемый как знак. \n\nOF  –  Overflow  Flag  (флаг  переполнения).  Он  устанавливается  в командах  сложения  и  вычитания  в  случае,  если  результат  операции  не помещается  в  формате  операндов.  При  этом  как  операнды,  так  и  результат  интерпретируются  как  знаковые  целые  числа.  В  аппаратную установку  этого  флага  положен  принцип  фиксации  переполнения  по сравнению  переносов  из  двух  старших  разрядов  при  сложении  или  заемов  в  два  старших  разряда  при  вычитании.  Если  один  из  переносов (заемов)  имеет  место,  а  другой  отсутствует,  то  происходит  переполнение формата (разрядной сетки).  ",
  "q3": "Умножение в дополнительных кодах с применением  коррекции:\nПри  использовании  традиционного  метода  умножения  в  дополнительных  кодах  только  в  случае  положительных  операндов  результат получается  в  явном  виде,  в  остальных  же  случаях  он  требует  коррекции.  Применяются  два  вида  коррекции:  а)  коррекция  в  ходе  перемножения  операндов;  б)  коррекция  окончательного  результата.  Коррекция первого  вида  имеет  место  при  отрицательном  множимом  и  состоит  в модифицированном  сдвиге  СЧП  вправо,  при  котором  в  освобождающийся старший разряд СЧП вносится единица. Коррекция второго вида производится  при  отрицательном  множителе  и  состоит  в  вычитании множимого из старших разрядов СЧП, которое может сводиться к сложению с дополнением множимого.\n\nУмножение в дополнительных кодах без коррекции:\nНаряду  с  традиционным  методом  умножения  в  дополнительных кодах,  требующим  коррекции  результата,  достаточно  широкое  применение  в    ЭВМ  находит  метод  Бута,  при  котором  не  требуется  выполнять  коррекцию.  Особенность  метода  состоит  в  выполнении  сложения или  вычитания  СЧП  и  множимого  на  каждом  шаге  умножения  в  зависимости  от  того,  как  после  сдвига  вправо  изменяется  младший  разряд множителя.  При  его  изменении  с  единицы  на  ноль  производится  сложение  СЧП  с  множимым,  а  при  изменении  с  нуля  на  единицу  –  вычитание множимого из СЧП, которое может быть реализовано как сложение  с  дополнением  множимого.  Если  младший  разряд  множителя  при сдвиге  не  изменяется,  то  на  данном  шаге  не  производится  сложения \n(вычитания), а выполняется только сдвиг СЧП и множителя вправо. При реализации этого метода происходит чередование сложений и вычитаний множимого и СЧП, вследствие чего старший  разряд СЧП в явном  виде  представляет  его  знак.  При  сдвиге  СЧП  вправо  значение знакового разряда сохраняется (арифметический сдвиг). "
}